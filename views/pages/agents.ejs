<%- include('../partials/header', { title: title }) %>

<style>
  /* Platform specific styling */
  .script-platform {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 8px;
    font-size: 0.85em;
    background: rgba(0, 0, 0, 0.2);
  }
  
  .platform-youtube {
    color: #FF0000;
    border: 1px solid #FF0000;
  }
  
  .platform-soundcloud {
    color: #FF5500;
    border: 1px solid #FF5500;
  }
  
  .platform-vimeo {
    color: #1AB7EA;
    border: 1px solid #1AB7EA;
  }
  
  .platform-patreon {
    color: #F96854;
    border: 1px solid #F96854;
  }
  
  .platform-bambicloud {
    color: #CD7CFF;
    border: 1px solid #CD7CFF;
  }
  
  .platform-hypnotube {
    color: #00B0FF;
    border: 1px solid #00B0FF;
  }
  
  .platform-twitter {
    color: #1DA1F2;
    border: 1px solid #1DA1F2;
  }
  
  .platform-reddit {
    color: #FF4500;
    border: 1px solid #FF4500;
  }
  
  .platform-discord {
    color: #7289DA;
    border: 1px solid #7289DA;
  }
  
  .platform-github {
    color: #6e5494;
    border: 1px solid #6e5494;
  }
  
  .script-category {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 8px;
    font-size: 0.85em;
    background: rgba(0, 0, 0, 0.2);
    color: #ffcc00;
    border: 1px solid #ffcc00;
  }
  
  .script-wordcount, .script-date {
    display: inline-flex;
    margin-right: 8px;
    font-size: 0.85em;
    opacity: 0.8;
  }
  
  .text-script-item {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.2);
    border-left: 3px solid #00ffff;
  }
  
  .text-script-item:hover {
    background: rgba(0, 0, 0, 0.3);
  }
  
  .script-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
  }
  
  .script-title {
    font-weight: bold;
    color: #00ffff;
  }
  
  .script-relevance {
    color: #ffcc00;
  }
  
  .script-meta {
    margin-bottom: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  
  .script-preview {
    font-size: 0.9em;
    line-height: 1.4;
    opacity: 0.8;
    white-space: pre-line;
    max-height: 4.2em;
    overflow: hidden;
  }
</style>

<div class="container">
  <h1>ü§ñ AI Agents Dashboard</h1>
  
  <div class="agent-grid">
    <!-- Knowledge Base Agent -->
    <div class="agent-card" id="knowledge-agent">
      <div class="agent-header">
        <h3>üìö Knowledge Base Agent</h3>
        <div class="agent-status" id="agent-status">
          <span class="status-dot"></span>
          <span class="status-text">Checking...</span>
        </div>
      </div>
      
      <div class="agent-stats" id="agent-stats">
        <div class="stat-item">
          <span class="stat-label">Knowledge Entries:</span>
          <span class="stat-value" id="knowledge-count">-</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Auto Discovery:</span>
          <span class="stat-value" id="auto-discovery">-</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Uptime:</span>
          <span class="stat-value" id="uptime">-</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Memory Usage:</span>
          <span class="stat-value" id="memory">-</span>
        </div>
      </div>
        <div class="agent-actions">
        <button class="btn-primary" onclick="triggerDiscovery()">üîç Discover Content</button>
        <button class="btn-secondary" onclick="refreshStatus()">üîÑ Refresh Status</button>
        <button class="btn-secondary" onclick="testCrawl()">üß™ Test Crawl (Google)</button>
      </div>
      
      <!-- URL Submission Form -->
      <div class="url-submission-section">
        <h4>üåê Submit URL for Analysis</h4>
        <div class="url-form">
          <input type="url" id="url-input" placeholder="Enter URL to crawl and analyze..." class="url-input">
          <button class="btn-primary" onclick="submitUrl()">üöÄ Submit & Crawl</button>
        </div>        <p class="form-help">
          Submit a URL and the agent will crawl it for relevant BambiSleep content, automatically extract scripts/transcripts, and add them to the knowledge base.
        </p>
      </div>
      
      <!-- Progress Bar -->
      <div class="crawl-progress" id="crawl-progress" style="display: none;">
        <div class="progress-header">
          <span class="progress-status" id="progress-status">Initializing...</span>
          <span class="progress-percentage" id="progress-percentage">0%</span>
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar" id="progress-bar" style="width: 0%;"></div>
        </div>
        <div class="progress-details" id="progress-details">
          <span class="progress-current" id="progress-current">Preparing to crawl...</span>
        </div>
      </div>
      
      <div class="agent-logs" id="discovery-logs">
        <h4>Recent Activity</h4>
        <div class="log-container" id="log-output">
          <p class="log-entry">Agent monitoring initialized...</p>
        </div>
      </div>

      <!-- Text Scripts Section -->      <div class="text-scripts-section">
        <h4>üìù Recent Text Scripts</h4>
        <div class="text-scripts-stats">
          <span class="stat-label">Total Scripts:</span>
          <span class="stat-value" id="text-scripts-count">-</span>
        </div>
        <div class="text-scripts-preview" id="text-scripts-preview">
          <p class="loading-text">Loading text scripts...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* Platform specific styling */
  .script-platform {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 8px;
    font-size: 0.85em;
    background: rgba(0, 0, 0, 0.2);
  }
  
  .platform-youtube {
    color: #FF0000;
    border: 1px solid #FF0000;
  }
  
  .platform-soundcloud {
    color: #FF5500;
    border: 1px solid #FF5500;
  }
  
  .platform-vimeo {
    color: #1AB7EA;
    border: 1px solid #1AB7EA;
  }
  
  .platform-patreon {
    color: #F96854;
    border: 1px solid #F96854;
  }
  
  .platform-bambicloud {
    color: #CD7CFF;
    border: 1px solid #CD7CFF;
  }
  
  .platform-hypnotube {
    color: #00B0FF;
    border: 1px solid #00B0FF;
  }
  
  .platform-twitter {
    color: #1DA1F2;
    border: 1px solid #1DA1F2;
  }
  
  .platform-reddit {
    color: #FF4500;
    border: 1px solid #FF4500;
  }
  
  .platform-discord {
    color: #7289DA;
    border: 1px solid #7289DA;
  }
  
  .platform-github {
    color: #6e5494;
    border: 1px solid #6e5494;
  }
  
  .script-category {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 8px;
    font-size: 0.85em;
    background: rgba(0, 0, 0, 0.2);
    color: #ffcc00;
    border: 1px solid #ffcc00;
  }
  
  .script-wordcount, .script-date {
    display: inline-flex;
    margin-right: 8px;
    font-size: 0.85em;
    opacity: 0.8;
  }
  
  .text-script-item {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.2);
    border-left: 3px solid #00ffff;
  }
  
  .text-script-item:hover {
    background: rgba(0, 0, 0, 0.3);
  }
  
  .script-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
  }
  
  .script-title {
    font-weight: bold;
    color: #00ffff;
  }
  
  .script-relevance {
    color: #ffcc00;
  }
  
  .script-meta {
    margin-bottom: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  
  .script-preview {
    font-size: 0.9em;
    line-height: 1.4;
    opacity: 0.8;
    white-space: pre-line;
    max-height: 4.2em;
    overflow: hidden;
  }
</style>

<script src="/socket.io/socket.io.js"></script>
<script>
// Socket.IO connection
const socket = io();

// Agent monitoring functionality
let agentStatus = null;

// Log entry function
function addLogEntry(message) {
  const logContainer = document.getElementById('log-output');
  if (logContainer) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
  }
  console.log(`[${new Date().toLocaleTimeString()}] ${message}`);
}

async function fetchAgentStatus() {
  try {
    const response = await fetch('/api/agent/status');
    const status = await response.json();
    agentStatus = status;
    updateAgentDisplay(status);
  } catch (error) {
    console.error('Failed to fetch agent status:', error);
    updateAgentDisplay({ status: 'error', error: error.message });
  }
}

function updateAgentDisplay(status) {
  const statusDot = document.querySelector('.status-dot');
  const statusText = document.querySelector('.status-text');
  
  if (status.status === 'operational') {
    statusDot.className = 'status-dot status-online';
    statusText.textContent = 'Operational';
  } else {
    statusDot.className = 'status-dot status-offline';
    statusText.textContent = 'Error';
  }
  
  // Update stats
  document.getElementById('knowledge-count').textContent = status.knowledgeEntries || '-';
  document.getElementById('auto-discovery').textContent = status.autoDiscovery ? 'Enabled' : 'Disabled';
  document.getElementById('uptime').textContent = formatUptime(status.uptime);
  document.getElementById('memory').textContent = formatMemory(status.memoryUsage?.heapUsed);
}

function formatUptime(seconds) {
  if (!seconds) return '-';
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  return `${hours}h ${minutes}m`;
}

function formatMemory(bytes) {
  if (!bytes) return '-';
  return `${Math.round(bytes / 1024 / 1024)}MB`;
}

async function triggerDiscovery() {
  const button = event.target;
  button.disabled = true;
  button.textContent = 'üîç Discovering...';
  
  try {
    const response = await fetch('/api/agent/discover', { method: 'POST' });
    const result = await response.json();
    
    addLogEntry(`Discovery completed: ${result.processed || 0} items processed, ${result.errors || 0} errors`);
    await fetchAgentStatus();
  } catch (error) {
    addLogEntry(`Discovery failed: ${error.message}`);
  } finally {
    button.disabled = false;
    button.textContent = 'üîç Discover Content';
  }
}

function refreshStatus() {
  fetchAgentStatus();
  addLogEntry('Status refreshed');
}

async function testCrawl() {
  const testButton = event.target;
  testButton.disabled = true;
  testButton.textContent = 'üß™ Testing...';
  
  addLogEntry('üß™ Testing crawl functionality with Google.com');
  
  try {
    const response = await fetch('/api/agent/submit-url', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ url: 'https://www.google.com' })
    });
    
    const result = await response.json();
    
    if (result.success) {
      addLogEntry(`üß™ Test successful: Found ${result.linksFound || 0} links, added ${result.added || 0} to knowledge base`);
    } else {
      addLogEntry(`üß™ Test failed: ${result.message || 'Unknown error'}`);
    }
  } catch (error) {
    addLogEntry(`üß™ Test error: ${error.message}`);
  } finally {
    testButton.disabled = false;
    testButton.textContent = 'üß™ Test Crawl (Google)';
  }
}

async function submitUrl() {
  const urlInput = document.getElementById('url-input');
  const url = urlInput.value.trim();
  
  if (!url) {
    addLogEntry('Error: Please enter a URL');
    return;
  }
  
  if (!isValidUrl(url)) {
    addLogEntry('Error: Please enter a valid URL');
    return;
  }
  
  const submitButton = event.target;
  submitButton.disabled = true;
  submitButton.textContent = 'üöÄ Crawling...';
  
  // Show progress bar with simulated progression
  showProgressBar();
  
  // Start simulated progress
  let currentProgress = 0;
  const progressSteps = [
    { progress: 10, status: 'Initializing crawl...', details: 'Connecting to target URL...', delay: 500 },
    { progress: 25, status: 'Analyzing page structure...', details: 'Scanning for content and links...', delay: 800 },
    { progress: 40, status: 'Extracting content...', details: 'Processing page content...', delay: 1000 },
    { progress: 60, status: 'Analyzing for scripts...', details: 'Searching for BambiSleep content...', delay: 1200 },
    { progress: 80, status: 'Processing knowledge...', details: 'Adding relevant content to knowledge base...', delay: 800 }
  ];
  
  addLogEntry(`Starting crawl of: ${url}`);
  updateProgress(0, 'Starting crawl...', 'Preparing to connect...');
  
  // Simulate realistic progress
  const progressInterval = simulateProgress(progressSteps);
  
  try {
    const response = await fetch('/api/agent/submit-url', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ url: url })
    });
    
    // Clear simulated progress
    clearInterval(progressInterval);
    
    const result = await response.json();
    
    if (result.success) {
      // Complete the progress bar
      updateProgress(100, 'Crawl completed!', 'Processing complete');
      
      let message = `‚úÖ Crawl completed: ${result.linksFound || 0} links found, ${result.added || 0} added to knowledge base`;
      
      // Show script extraction info
      if (result.scriptsExtracted && result.scriptsExtracted > 0) {
        message += ` (üé≠ ${result.scriptsExtracted} script(s) auto-extracted!)`;
      }
      
      addLogEntry(message);
      urlInput.value = '';
      await fetchAgentStatus();
      
      // Hide progress bar after success
      setTimeout(() => hideProgressBar(), 2000);
    } else {
      updateProgress(100, 'Crawl failed', `‚ùå ${result.message || 'Unknown error'}`);
      addLogEntry(`‚ùå Crawl failed: ${result.message || 'Unknown error'}`);
      setTimeout(() => hideProgressBar(), 3000);
    }
  } catch (error) {
    // Clear simulated progress
    clearInterval(progressInterval);
    updateProgress(100, 'Crawl error', `‚ùå ${error.message}`);
    addLogEntry(`‚ùå Crawl error: ${error.message}`);
    setTimeout(() => hideProgressBar(), 3000);
  } finally {
    submitButton.disabled = false;
    submitButton.textContent = 'üöÄ Submit & Crawl';
  }
}



function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Progress bar functions
function showProgressBar() {
  document.getElementById('crawl-progress').style.display = 'block';
}

function hideProgressBar() {
  document.getElementById('crawl-progress').style.display = 'none';
  // Reset progress bar
  const progressBar = document.getElementById('progress-bar');
  progressBar.style.width = '0%';
  progressBar.classList.remove('complete', 'active');
  updateProgress(0, '', '');
}

function updateProgress(percentage, status, details) {
  const progressBar = document.getElementById('progress-bar');
  const progressPercentage = document.getElementById('progress-percentage');
  const progressStatus = document.getElementById('progress-status');
  const progressCurrent = document.getElementById('progress-current');
  
  // Smooth animation for progress bar
  const safePercentage = Math.min(100, Math.max(0, percentage));
  progressBar.style.width = safePercentage + '%';
  progressPercentage.textContent = Math.round(safePercentage) + '%';
  progressStatus.textContent = status;
  progressCurrent.textContent = details;
  
  // Add visual feedback
  if (safePercentage >= 100) {
    progressBar.classList.add('complete');
    progressBar.classList.remove('active');
  } else if (safePercentage > 0) {
    progressBar.classList.add('active');
    progressBar.classList.remove('complete');
  } else {
    progressBar.classList.remove('active', 'complete');
  }
}

// Simulated progress function for realistic user feedback
function simulateProgress(steps) {
  let stepIndex = 0;
  let currentProgress = 0;
  
  const progressInterval = setInterval(() => {
    if (stepIndex < steps.length) {
      const step = steps[stepIndex];
      
      // Gradually increase progress to the next step
      const targetProgress = step.progress;
      const progressIncrement = (targetProgress - currentProgress) / 10;
      
      if (currentProgress < targetProgress) {
        currentProgress += progressIncrement;
        updateProgress(currentProgress, step.status, step.details);
      } else {
        // Move to next step
        currentProgress = targetProgress;
        updateProgress(currentProgress, step.status, step.details);
        stepIndex++;
        
        // Add some delay between steps for realism
        setTimeout(() => {}, step.delay || 500);
      }
    }
  }, 100); // Update every 100ms for smooth animation
  
  return progressInterval;
}

// Fetch and display text scripts
async function fetchTextScripts() {
  try {
    const response = await fetch('/api/agent/text-scripts');
    if (!response.ok) return null;
    const scripts = await response.json();
    updateTextScriptsDisplay(scripts);
    return scripts;
  } catch (error) {
    console.error('Failed to fetch text scripts:', error);
    return null;
  }
}

function updateTextScriptsDisplay(scripts) {
  if (!scripts || !scripts.length) {
    document.getElementById('text-scripts-count').textContent = '0';
    document.getElementById('text-scripts-preview').innerHTML = '<p class="loading-text">No text scripts found.</p>';
    return;
  }
  
  // Update count
  document.getElementById('text-scripts-count').textContent = scripts.length;
  
  // Update preview
  const previewContainer = document.getElementById('text-scripts-preview');
  previewContainer.innerHTML = '';
  
  scripts.slice(0, 5).forEach(script => {
    // Get platform icon
    let platformIcon = 'üåê';
    let platformClass = '';
    if (script.platform) {
      platformClass = `platform-${script.platform}`;
      switch(script.platform) {
        case 'youtube': platformIcon = 'üì∫'; break;
        case 'soundcloud': platformIcon = 'üéµ'; break;
        case 'vimeo': platformIcon = 'üé¨'; break;
        case 'patreon': platformIcon = 'üí∞'; break;
        case 'bambicloud': platformIcon = 'üåô'; break;
        case 'hypnotube': platformIcon = 'üí´'; break;
        case 'twitter': platformIcon = 'üê¶'; break;
        case 'reddit': platformIcon = 'üì±'; break;
        case 'discord': platformIcon = 'üí¨'; break;
        case 'github': platformIcon = 'üì¶'; break;
      }
    }
    
    const scriptElement = document.createElement('div');
    scriptElement.className = 'text-script-item';
    scriptElement.innerHTML = `
      <div class="script-header">
        <span class="script-title">${script.title}</span>
        <span class="script-relevance">‚≠ê ${script.relevance}/10</span>
      </div>
      <div class="script-meta">
        <span class="script-category">${script.category || 'scripts'}</span>
        ${script.platform ? `<span class="script-platform ${platformClass}">${platformIcon} ${script.platform}</span>` : ''}
        <span class="script-wordcount">${script.wordCount || 'Unknown'} words</span>
        <span class="script-date">Added: ${new Date(script.addedAt || script.timestamp).toLocaleDateString()}</span>
      </div>
      <div class="script-preview">${script.description || script.content.substring(0, 150)}${script.content.length > 150 ? '...' : ''}</div>
    `;
    previewContainer.appendChild(scriptElement);
  });
  
  if (scripts.length > 5) {
    const moreElement = document.createElement('div');
    moreElement.className = 'scripts-more';
    moreElement.innerHTML = `<p>... and ${scripts.length - 5} more scripts</p>`;
    previewContainer.appendChild(moreElement);
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  fetchAgentStatus();
  fetchTextScripts();
  // Refresh status every 30 seconds
  setInterval(fetchAgentStatus, 30000);
  // Refresh text scripts every 60 seconds
  setInterval(fetchTextScripts, 60000);
  // Listen for crawl progress updates
  socket.on('crawl:progress', (data) => {
    // Override simulated progress with real progress if available
    if (data.percentage !== undefined) {
      updateProgress(data.percentage, data.status || 'Processing...', data.details || 'Working...');
    }
    if (data.logMessage) {
      addLogEntry(data.logMessage);
    }
  });
  
  socket.on('crawl:complete', (data) => {
    updateProgress(100, 'Crawl completed!', `‚úÖ Found ${data.linksFound || 0} links, added ${data.added || 0} to knowledge base`);
    addLogEntry(`‚úÖ Crawl completed: ${data.linksFound || 0} links found, ${data.added || 0} added to knowledge base`);
    
    // Show detailed success/failure breakdown
    if (data.summary) {
      const { totalProcessed, successful, failed } = data.summary;
      addLogEntry(`üìä Results breakdown: ${totalProcessed} total, ${successful} successful, ${failed} failed`);
    }
    
    setTimeout(() => hideProgressBar(), 3000);
  });
  
  socket.on('crawl:error', (data) => {
    updateProgress(100, 'Crawl failed', `‚ùå ${data.message || 'Unknown error'}`);
    addLogEntry(`‚ùå Crawl failed: ${data.message || 'Unknown error'}`);
    if (data.details) {
      addLogEntry(`üîç Error details: ${data.details}`);
    }
    setTimeout(() => hideProgressBar(), 3000);
  });
  
  socket.on('crawl:step', (data) => {
    // Handle individual step updates from server
    if (data.step && data.totalSteps) {
      const percentage = Math.round((data.step / data.totalSteps) * 100);
      updateProgress(percentage, data.status || `Step ${data.step}/${data.totalSteps}`, data.details || 'Processing...');
    }
    if (data.logMessage) {
      addLogEntry(data.logMessage);
    }
  });
});

</script>

<%- include('../partials/footer') %>
